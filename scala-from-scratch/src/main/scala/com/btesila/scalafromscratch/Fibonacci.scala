package com.btesila.scalafromscratch

object Fibonacci {

  /**
   * So what is the problem with this implementation? After all, fib1 does not violate
   * referential transparency, right? All the mutable state is purely local and never
   * exposed to the outside world. That is indeed true. If you don’t break referential
   * transparency, using local mutable state inside of a function can be perfectly fine. In
   * fact, it’s a good choice if it leads to at least one of the following outcomes:
   *
   * • It makes your code easier to read
   * • It solves a performance problem in a critical path
   *
   * The main problem with fib1 is that it is focused a lot on the low-level details of how
   * to calculate the fibonacci number, instead of describing what is to be calculated.
   */
  def fib1(n: Long): Long = {
    var previous = 0L
    var current = 1L
    var result = previous
    var i = 1L

    while (i < n) {
      i += 1
      result = previous + current
      previous = current
      current = result
    }

    result
  }

  /**
   * I think this is much more readable than fib1. In fact, it is almost as if we are
   * reading the specification — we are describing what we want to do, instead of getting
   * lost in implementation details like switching variables around and incrementing a
   * counter. One of the big benefits of functional programming is exactly that you tend
   * to describe what you want to do instead of how to arrive there. As a result, the intent
   * behind your code becomes clearer than in imperative programming.
   */
  def fib2(n: Long): Long =
    if (n > 1) fib2(n - 1) + fib2(n - 2)
    else n


  /**
   * scala> val x = timedFib1(50)
   * Elapsed time: 0.017437 milliseconds
   *
   * scala> val y = timedFib2(50)
   * Elapsed time: 41889.603047 milliseconds
   *
   * The problem with recursion is that we are putting a
   * lot of stack frames onto the call stack — fib2(50) cannot complete before fib2(48)
   * and fib2(49) have completed, and these, in turn, need to wait for fib2(46) and
   * fib2(47), or fib(47) and fib(48), respectively. And so on. This is not only bad for
   * performance, but can also lead to stack overflow errors at runtime.
   */
  def timed(f: Long => Long): Long => Long = x => {
    val start = System.nanoTime
    val result = f(x)
    val end = System.nanoTime
    val elapsed = (end - start) / 1000000.0
    println("Elapsed time: " + elapsed + " milliseconds")
    result
  }

  /**
   * Tail recursion - the recursive call is the last thing that
   * happens in the function.
   * If that is the case, the Scala compiler will automatically
   * optimise the generated byte code and turn the whole thing into a loop for us.
   *
   * scala> val x = timedFib3(50)
   * Elapsed time: 0.010558 milliseconds
   * x: Long = 12586269025
   *
   */
  def fib3(n: Long): Long = {
    @scala.annotation.tailrec
    def fibAcc(previous: Long, current: Long, n: Long): Long =
      if (n == 0) current
      else fibAcc(current, previous + current, n - 1)

    if (n > 1) fibAcc(1, 1, n - 2) else n
  }
}
